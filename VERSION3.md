# GDNSD VERSION 3 EXTENDED RELEASE NOTES

This is an attempt at a human-usable breakdown of all the human-affecting changes in the major version bump from gdnsd 2.x to 3.x.

## Notable Feature Changes

### DNS

* The TCP DNS code was upgraded substantially:
  * Follows the spirit and recommendations of RFC 7766 "DNS Transport over TCP - Implementation Requirements"
  * Supports TCP Fastopen
  * Implements the RFC 7828 edns0 tcp-keepalive option
  * Internal connection idle timeouts scale with connection load
  * Resiliency under heavy load or attack-like conditions, including slow-read/write, is much improved and should allow legitimate clients to continue making requests
  * Several new stat counters added for per-connection TCP stats, alongside the existing per-request ones:
    * `tcp_conns` - TCP conns we accepted (excludes extremely early failures, e.g. accept() itself returning an error)
    * `tcp_close_c` - TCP conns closed cleanly by the client
    * `tcp_close_s_ok` - TCP conns closed cleanly by the server, usually due to an idle timeout being reached or during thread shutdown, etc.
    * `tcp_close_s_err` - TCP conns closed by the server due to an error such as `tcp_recvfail`, `tcp_sendfail`, or `dropped` from the general stats.
    * `tcp_close_s_kill` - TCP conns closed by the server, which were killed early to make room for a new client when `max_clients_per_thread` was reached.
* edns-client-subnet support updated to match RFC 7871, and is now always enabled
* The nsid edns0 option from RFC 5001 is implemented, allowing identification of members of a loadbalanced or anycast server set
* All responses are completely minimized:
  * A and AAAA responses no longer include opposite-family records in the additional section
  * The answer section usually contains only one rrset, unless CNAMEs are involved (we still output CNAME chains within local zone data)
  * The auth section is only ever used for negative responses (1x SOA) and delegations (NS records at a zone cut)
  * The additional section only ever contains actual mandatory glue IPs (out-of-zone glue or glue within any delegated subzone of the delegating zone).

### Zonefiles

* Zone (re-)loading still scans the zones directory for zonefiles and automatically names zones based on filenames as before
* Zonefiles are now only ever reloaded by explicit command, never by filesystem monitoring
* Zone reloads are considered synchronous and atomic: there is no mechanism to reload individual zones, and the entire dataset must load successfully or none of it affects the runtime
* `$INCLUDE` files supported (use subdirectories, which are otherwise ignored, to avoid confusing them for zones)
* Symlinks now work for aliasing zones, assuming there are no explicit references to the zone name within the data.  To help with that:
* `@Z` and `@F` macros implemented, which represent the original (line zero) `$ORIGIN` of the zone or the current file.  You can use these in situations like: `$ORIGIN foo.@F [... records ...] $ORIGIN bar.@F`, which would otherwise be impossible without hardcoding the zone name in the second origin statement, breaking symlink zone aliasing
* If an SOA's serial is zero, it will be autogenerated from file mtimes as YYMMDDHHMM, using the timestamp of the most-recent of all included files

### gdnsdctl

The daemon now has a control socket, and `gdnsdctl` is shipped as the canonical client for it.  All gdnsdctl commands are synchronous and status-reporting, meaning they do not exit until the requested operation has either succeeded or failed fully, and always reflect success with a zero exit code and failure with non-zero.  The commands currently implemented by gdnsdctl include:

* `status` - Basic status check, reports version and PID of running daemon
* `stats` - Dumps current statistics from the daemon in JSON format to stdout
* `states` - As above, but states for healthcheck monitoring
* `stop` - Stops the running daemon
* `reload-zones` - Reloads zonefiles
* `acme-dns-01` - Creates ephemeral TXT records for ACME DNS-01 challenge responses
* `replace` - Requests that the daemon replace itself seamlessly (no downtime, no lost requests):
  * Replacement is a fresh execution of the same binary pathname with CLI options preserved
  * Spawned as a child of the running daemon in order to preserve as much execution context as possible
  * The old and new daemons communicate with each other over a separate control socket connection for coordination and smooth socket handoff
  * The old daemon can continue operations as it was before if the new dies before finishing the handoff
  * gdnsdctl monitors the entire sequence: watches the previous daemon report a successful takeover by the replacement, witnesses the exit of the old daemon, and reconnects to the new daemon to ensure it survived the transition
  * This mechanism supports seamless configuration changes or code updates without dropping requests
  * Critically, this mechanism is systemd compatible

### Feature Regressions

* The geoip plugin no longer supports the legacy GeoIP1 database format
* The `listen => scan` option, which scanned interfaces for IPs to bind to, has been removed completely.  It was deprecated with runtime warnings and removed from the documentation back in v2.2.0
* The HTTP listener and its previous stats/state output code in various formats is gone completely, replaced by the control socket stuff above
* Automatic and/or asynchronous per-zonefile reloads are gone completely.  All zone data reloads are now commanded, synchronous, and atomic with respect to the entire dataset
* The daemon no longer reloads zonefiles on SIGUSR1, but it does handle the signal as a no-op with a warning for compatibility reasons.
* The daemon does not implement any security-related code anymore.  This job has been foisted off on the init script/system (more on this below in "Security, daemon management, and init systems")
* The semantics of the sub-fields of NAPTR records are no longer validated in any way
* NS record nameserver hostnames are no longer allowed to point at DYNA records in local data
* NS record sets are limited to 64 records per set and are no longer randomly rotated in the output
* The server does not support emitting responses greater than ~16KB in size over any protocol.  Zone data is explicitly validated against this constraint, and zonefiles will fail to load if they contain record sets which could generate an over-sized response packet.  The checks are somewhat conservative in corner cases and may reject data which would technically barely fit in practice.
* DYNC and related plugin configurations have two new restrictions: all configured dynamic CNAME values must be fully-qualified (end in dot), and DYNC cannot be used to emit a CNAME that points into the same zone (in others words, if `example.com` has the RR `foo DYNC %weighted!some-cnames`, the weighted plugin's configuration for the resource `some-cnames` cannot contain any CNAME values within the zone `example.com`; they must be names in other domains).

### Other minor things

* The GeoIP distance calculations are now slightly faster and more accurate.
* The source code has been through a bunch of cleanup for clarity, simplicity, and formatting

## Configuration changes

### New options

These are all new options for new features:

* `acme_challenge_ttl` - Sets the time in seconds for records injected by `gdnsdctl acme-dns-01` to expire, as well as the advertised TTL.  min/def/max is 60/600/3600.
* `nsid` - Sets the raw binary data returned by the NSID edns0 option.  Up to 128 raw bytes, encoded as up to 256 characters of ascii hex in a single string.  The option is not sent unless the data is explicitly defined by this option.
* `tcp_fastopen` - Sets the queue size for TCP Fastopen (global, per-socket).  min/def/max is 0/128/1048576, zero disables.

### Options with changed defaults or allowed values

You'll need to fix values for these in existing config before trying an upgrade, if your current values are out of range for the new limits:

* `max_edns_response` - max changed from 64000 to 16384
* `tcp_threads` - Default changed from 1 to 2, minimum changed from 0 to 1
* `tcp_timeout` - min/default/max changed from 3/5/60 to 5/15/60
* `udp_threads` - Default changed from 1 to 2, minimum changed from 0 to 1

### Options removed completely

None of these generate a syntax error for now, they merely log a non-fatal error to ease transition.  They'll become syntax errors in a future major version update:

* `any_mitigation` - Fixed on (same as previous default)
* `edns_client_subnet` - Fixed on (same as previous default)
* `include_optional_ns` - Fixed off (same as previous default)
* `max_addtl_rrsets` - No longer applicable
* `max_cname_depth` - Fixed at 16 (same as previous default)
* `max_response` - Fixed 16384 (same as previous default)
* `udp_recv_width` - Fixed at 16 (prev default was 8)
* `zones_strict_startup` - Fixed on (same as previous default)

* `zones_rfc1035_auto` - Removed with zonefile autoscanning
* `zones_rfc1035_auto_interval` - Removed with zonefile autoscanning
* `zones_rfc1035_quiesce` - Removed with zonefile autoscanning

* `http_listen` - Removed with HTTP listener
* `http_port` - Removed with HTTP listener
* `http_timeout` - Removed with HTTP listener
* `log_stats` - Removed with HTTP listener
* `max_http_clients` - Removed with HTTP listener
* `realtime_stats` - Removed with HTTP listener

* `priority` - see "Security, daemon management, and init systems" below
* `username` - see "Security, daemon management, and init systems" below
* `weaker_security` - see "Security, daemon management, and init systems" below

## Commandline changes for the main daemon

* All of these CLI action verbs are removed and effectively replaced by `gdnsdctl`: `stop`, `reload-zones`, `restart`, `condrestart`, `try-restart`, `status`.
* The remaining verbs are:
  * `start` - Starts a foreground process, non-daemonizing with log output to stderr by default.
  * `daemonize` - Starts a background daemon process.  The daemonization is minimal, but correct and complete.  It properly goes through the `fork()->setsid()->fork()` sequence, it ignores `SIGHUP` (unlike `start`), and it closes off the stdio files and sends its logging to syslog.  The original foreground process waits on the daemonized child to report successful startup (through offering live runtime service) before it exits with status zero.
  * `checkconf` - Goes through much of the initial sequence of `start`, including loading the configuration and zonefiles, but does not attempt to start runtime listener services or control socket code.
* Flags:
  * Unchanged: `-c` - sets the configuration directory, if not using the hardcoded default path from build time.
  * Unchanged: `-D` - requests debug-level logging output (in production builds it's not too spammy for most things.  In `--enable-developer` debug builds, the output from this flag can be unreasonably verbose).
  * Removed: `-f` (foreground) - replaced by the `start`/`daemonize` distinction above
  * Removed: `-x` (no syslog) - Stderr logging is the default
  * Removed: `-s` (zones strict startup) - this is now always true and doesn't make sense as a flag
  * Added: `-l` - explicitly switches log output from stderr to syslog for the `start` and `checkconf` actions.
  * Added: `-R` - allows `start` or `daemonize` to replace another running daemon instance in a smooth (downtime-less, loss-free) way.  This is what's used when the daemon spawns its own replacement process when commanded to do so by `gdnsdctl replace`.  Without `-R`, if another daemon instance were already running, `start` or `daemonize` would complain and exit.

All the removed flags (`-f`, `-s`, and `-x`) are still allowed for compatibility reasons and emit non-fatal log messages, to ease transition of tools/scripts.

## Security, daemon management and init systems

The TL;DR here is that gdnsd doesn't manage its own OS security or privileges anymore.  It just runs and assumes the environment was already secured by the init system or script, and assumes it can bind port 53.  The init script/system is also responsible for taking care of other optional bits gdnsd used to do for itself as root before dropping its own privileges: setting the working directory sanely, setting locked memory (and/or other) resource limits, setting process priority, dropping privileges for the daemon, etc.  Since most installations will want gdnsd to run as a non-root user and also to bind port 53, that means a system-specific mechanism will have to be employed by the init script/system to allow the non-root user to bind port 53.  For Linux this means `CAP_NET_BIND_SERVICE`, and for FreeBSD I think it's `mac_portacl`, but in general this is not an area where portable solutions exist.  More rationale and background on this further down below.

For systemd-based Linux distributions, an example unit file which handles all the things is built along with the software at `sysd/gdnsd.service`.  For traditional initscript systems, you'll have to piece it together from commands in the initscript such as `ulimit`, `nice`, `su`, the BSD `daemon` command, etc.

## Other changes of interest to builders and packagers

* Autotools updates: building from git now requires autoconf 2.64+ and automake 1.13+
* The userspace-rcu library (liburcu) is now a build requirement rather than an optional recommendation
* GeoIP2 support, while still optional, requires libmaxminddb 1.2.0+ if enabled at all
* In general, lots of source-level backwards compatibility for older systems and/or kernels was removed where the assumptions seemed safe for a new major release in late 2018 or after.  If cases arise where certain operating systems are still in support and require patching, I'd be happy to add back the necessary bits.  Examples here include the assumptions about `SO_REUSEPORT`, `SOCK_CLOEXEC`, `SOCK_NONBLOCK`, and `accept4()`.
* The generated C sources `src/zscan_rfc1035.c` and `libgdnsd/vscf.c`, which are built with `ragel`, are once again being included in tarball releases, but not in the git repo.  This is in response to ragel dependency hell reported by some who build from source on every machine.

## Rationale and Philosophy

This isn't a corporate-backed software.  There's no budget or team or financial interest at all.  Most of this software is written by me, a lone author who mostly works on this in gaps of spare time when I'm able.  I love the 3rd-party contributions the codebase has had from others over the years, but they've all been fairly minor in total scope.  We happen to also use it in production at my current day job at the non-profit Wikimedia Foundation, and also did so at my previous employer Logitech, and in those capacities I've occasionally been able to expend real work hours on this project where it directly impacted features we needed or bugs we cared about.  Beyond that though, while I have a fondness for this project and take pride in it, my time is limited.  This is reflected in the sometimes glacial pace of major feature development.  I'm also not the among the best developers in the world, so my capacity for handling increases in the complexity of this project is limited.  Any excess complexity burden slows things down even more.

I'm not a fan of the way most software is developed, where features accrete on features in endless succession like barnacles attaching to the hull of a ship until there's more barnacles than ship.  I think most developers don't spend enough time on quality, on refactoring, or on cleanliness, and I think they don't weigh the costs of every new feature (and every piece of old compatibility cruft) as heavily as they should.  I'm also not a fan of the kind of personal rigidity where one never questions one's own past decisions and thoughts.  I regularly make stupid design mistakes, and I don't want to have to live with them forever.  Software projects should at least try to value simplicity and purposeful design, and try to avoid the [Second System Effect](https://en.wikipedia.org/wiki/Second-system_effect).

It is in light of these values and my limited time and complexity budget that I've opted to ungracefully eradicate large swaths of gdnsd code and features during the development cycle leading up to the major version bump for 3.x.  In some cases I've backtracked on feature or design decisions because I think my past intents and/or rationales were flawed.  Sometimes it's that the world changed.  Sometimes it's just not worth the complexity budget anymore.  Many times it's a combination of several such factors.

The git statistics from v2.4.0..v3.0 (well, at the time of this writing, slightly before the cut of the actual 3.0) are telling, and I'm proud of the reductions shown there.  Ignoring all the quibbles about real "Lines of Code" (vs comments and whitespace and documentation and tests and build cruft, etc) and just looking at the raw git stats on files and lines, there was a net reduction of ~4K lines:

```
git diff --stat v2.4.0
[...]
258 files changed, 13646 insertions(+), 17748 deletions(-)
```

4K lines removed is roughly 6% of the original total, and the "deletions" stat is around 28%, if that's any better measure of total change.  This is all in spite of adding several new features.

### The big changes around security, daemon management, and init systems

In the past, gdnsd has tried to take care of all security and daemon management functions internally.  It managed a number of execution aspects which typically require initial root privileges: setting process priority, raising the locked memory ulimit for `lock_mem => true`, binding the privileged port 53, limiting security scope via Linux -specific calls like prctl(), etc... and then took care of dropping its own process uid and gid to unprivileged ones safely and permanently.  Some of this was already portability-problematic for some platforms, but the real nail in the coffin for all of this was systemd.

Another key feature was the ability to do downtime-less restarts for changing code and/or configuration, and I had a strong desire to preserve that feature and try to keep it portable.  The original mechanisms gdnsd used for downtime-less restarts relied only on reasonably-portable assumptions and widely-available POSIX/unix APIs, and integrated well (if in a complicated manner!) with all of the privileged operations performed at startup above.  Because a running daemon had already permanently lost all of its elevated privileges, the new daemon during a replace had to be independently started as root to accomplish all the same things for itself, including critically the binding of port 53 (even with `SCM_RIGHTS` handoff, new listeners could be configured).

Systemd didn't allow for this to work the way it had under traditional init systems in the past, and as a result gdnsd 2.x lost this smooth replace-restart capability on systemd-based systems, which for better or worse came to dominate the Linux (and thus all servers) market during its lifetime.  The primary crux of incompatibility was that systemd wouldn't allow any kind of overlapped-restart by a process which wasn't a child of the original daemon and inheriting its cgroup settings, not even from processes started by other commands in the unit file such as `ExecReload`, and my various mailing list posts about finding ways to fix the situation and allow daemons to manage smooth restarts with independent replacement daemons fell on deaf ears.  And again, since the running daemon was unprivileged, there was no easy way for it to spawn a replacement that needed to perform privileged operations on startup.

I expended many months of effort and many ultimately-doomed code branches trying to come up with a sane way to still do everything else we were doing in this area portably while appeasing the requirements of systemd, but all of my efforts either resulted in other serious design flaws, or simply had way too high a complexity and fragility burden to be reasonable.  At the end of the day, the only reasonable path forward given systemd's dominance was to give in and structure things in the way that pleased systemd the most, while still preserving some ability to able to get similar results under traditional init systems and/or on non-Linux platforms manually, and that ended up being to push all related things back on the init system/script and be security-oblivious in the daemon code.  I apologize to all the non-systemd users, but I couldn't find a better way out of this mess!

## Future Directions

With the caveats that future is impossible to predict, and that if my thoughts on these subjects were fully-formed these things might already be done, these reflect my current mental state of affairs on various future gdnsd topics as of the release of 3.0.0:

### CPUs and IRQs

I'd like to implement auto-detection of CPU core counts for setting an automatic sane value for `udp_threads` and `tcp_threads`, perhaps ignoring thread-sibling CPU cores by default (physical core count rather than virtual).  Going a bit beyond this, we could also support explicitly taking better advantage of RSS IRQ spreading on Linux for those that have it configured, probably by allowing a manual or automatic mapping of I/O threads to CPU cores with affinity pinning, coupled with SO_ATTACH_REUSEPORT_EBPF or a similar mechanism to pin the traffic flow from card->gdnsd->card without ever leaving a single CPU core.  Possibly some of this should be NUMA-aware as well, as typically the NIC is attached directly to only one NUMA domain.  Some supporting features in this space may get added during a future 3.N feature release if I have time to sort out the details.

### Zone data and files

While I think 3.x's move to explicit, synchronous, whole reloads of all the zone data was the right move, I think some efficiency could be added back for those with giant sets of zonefiles without ruining the intent here.  Probably the simplest thing to do would be to track the full list of included files for a zone and all of their mtimes, and then simply not re-parse/load zones which haven't changed since they were last loaded, copying or aliasing the data over from the old dataset.  This would also need proper handling of symlink mtime/contents as well, to catch changes where e.g. a zone or include file is a symlink and just the symlink targeting changes.  Needs a flag to disable this as well, in case mtimes are known-bad or an operator with a small dataset doesn't want to take risks with mtime mistakes.

I still think we could hook up more advanced data backends, so long as they follow an explicit reload model.  For instance, we could have a SQL zone data backend, but there would be no live querying of SQL during live DNS response processing.  The data would be reloaded explicitly on-command, and the schema might ideally have some per-zone structure to it and some timestamp/serial by which we could optimize against reloading zones which haven't changed, as with files above.  I don't know when or if I'll have time to work on this myself, and I don't have any immediate needs for it myself, either.

### Healthchecking plugins

I really don't think healthcheck plugins belong inside this daemon anymore, I just haven't done the work to get rid of them.  I do think there's value in having dynamic resolution be able to use healthcheck states, I just think the complexity should be pushed outside of this C daemon, via mechanisms like the current `extmon` and `extfile` plugins.  Perhaps those should be the only healthcheck code in the daemon (in the core rather than as plugins), and everything else shifted externally.  The existing simple tcp/http/etc checks' code could be moved to example external tools that ship with gdnsd as well.  We could also perhaps support other existing pseudo-standards for easier integration (e.g. automatically be able to run nagios check scripts directly, and/or have some decent interface to get states directly from a nagios server).

### Dynamic resolution plugins

I think the plugin API for dynamic resolution has always been at the wrong abstraction level, but I wasn't able to finish sorting this out in time for 3.x.  All of the non-trivial resolver plugins (simplefo, multifo, weighted, metafo, and geoip) could operate from a unified structure and methodology that revolves around mapping, and at the very least could be deduplicated down to a single replacement plugin that does it all in a blended way.  Arguably if healthcheck plugins are gone too (see above), the singular replacement resolver plugin could just move into the core code.

It would make sense for this hypothetical universal resolver to have pluggable mapping methods (geoip being the canonical example), but then I don't know if I'd go back down the true `dlopen()` plugin road for that or not.  The APIs are never stable enough and all plugins could have more-easily just been source patches against a reasonably-well-documented internal core API, avoiding all the complexity and mess of `dlopen()`ing code and pretending we support some portable and stable external plugin ABI.

I hope to do some kind of work related to some of this for 4.x, but it's hard to say where it will all end up right now.  One of the real feature needs I have in this space over the coming year is the proper intersection of the 'weighted' and 'geoip' functionalities, where datacenters have weight values which can be dynamically adjusted at runtime (via the `admin_state` file, or via gdnsdctl?), and the weight affects distance calculations (you can think of it as growing or shrinking the bubble of mapped clients around a datacenter on the geographic map).  Probably something that supports those ideas will get implemented, even if all of the rest of the dramatic re-architecting doesn't happen.

### The DYNA/DYNC resource types in general

I'm not fond of the design at this level either.  Probably DYNC should only return CNAMEs and not addresses (not really sure about this one), and probably DYNA should be broken up into separate types for A and AAAA.  Doing this to the existing names without breaking compatibility is hard, so I'll probably invent new names and leave some support in place for the old ones.  In light of all this, it would probably behoove users to move away from solutions that require DYNC to be able to return addresses, as that may be a major compatibility barrier in a future major version upgrade.

### Various DNS protocol-level privacy and security issues

The DNS really isn't where I'd like it to be on protocol level privacy and security issues.  DNSSEC only attacks the "can you trust your cache?" part of the problem, but ignores privacy and censorship issues and creates a lot of other problems along the way.  Other efforts are attempting to encrypt DNS communications to avoid both passive and active MITM of DNS communications as well as privacy leaks on the wire, but none of them are quite where they need to be yet, at least for the authserver case.  My random thoughts on various related (pseudo-)standards:

DNSSEC - I still hate it.  I'm not going to detail all of its horrible faults here, it's easy enough these days to just provide links like [DNSSEC Outages](https://ianix.com/pub/dnssec-outages.html) (which has far more than outage info; scroll to the bottom for some great lists of DNSSEC-related CVEs and quotes from smart people bashing DNSSEC).  I think the DNS without DNSSEC is already incredibly complex, and with DNSSEC it's probably borderline impossible to build a reasonably-unbuggy implementation of an authserver that's reasonably fast and resilient.  I've been saying for years that I'll probably eventually be forced into implementing it by the rest of the world, but it hasn't happened yet!  There's a possible middle-ground on supporting it, where we implement DNSSEC-correct handling of the appropriate RR-types and flag bits (etc), but relegate all actual crypto to offline pre-signing/generation of the zonefile data.  Still sounds awful.

DNSCurve - I don't think DNSCurve is actually going anywhere anymore in terms of widespread adoption.  Much older versions of gdnsd implemented it for a while, but I eventually gave up on the standard.  I'm still sad about that, because there was a lot to really like about DNSCurve.  It just needed some minor fixups around key distribution and rollover practices (vs "encode the pubkey in the nameserver hostname").  DNSCrypt is similarly wonderful, but not applicable to gdnsd as an authserver.

DNS-over-HTTPS (DoH) - As far as I know, DoH efforts are only targeting the user-to-cache leg of things like DNSCrypt, and so they aren't really relevant here.  If this ever did apply to the authserver case, it would probably be simplest to just make it easy to configure a separate proxy daemon for it.

DNS-over-TLS (DoT) - Current standards for this also only target the user-to-cache leg, but DPRIVE is apparently eventually going to publish something about the cache-to-authserver leg, which is exciting.  I think we could implement this reasonably, assuming they don't end up making it require DNSSEC to be useful.  Ditto for DNS-over-DTLS (DoDTLS?).

EDNS0 Cookies - Doesn't really address privacy/censorship, but does offer a ToFU mechanism that makes blind forgery much harder in some cases (even harder than forging TCP blindly).  Implementing this almost made the cut for 3.x, but I didn't quite have the time left.  It may appear in a future 3.N feature release.
