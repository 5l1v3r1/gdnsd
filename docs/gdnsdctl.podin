=head1 NAME

gdnsdctl - Control socket client for gdnsd

=head1 SYNOPSIS

  Usage: gdnsdctl [-c @GDNSD_DEFPATH_CONFIG@] [-D] [-l] [-t 47] <action> [...]
    -c - Configuration directory (def @GDNSD_DEFPATH_CONFIG@)
    -D - Enable verbose debug output
    -l - Send logs to syslog rather than stderr
    -t - Timeout in seconds (def 47, range 5 - 300)
  Actions:
    stop - Stops the running daemon
    reload-zones - Reload the running daemon's zone data
    replace - Ask daemon to spawn a takeover replacement of itself (updates code, config, zone data)
    status - Checks the running daemon's status
    stats - Dumps JSON statistics from the running daemon
    states - Dumps JSON monitored states
    acme-dns-01 - Create ACME DNS-01 payloads from additional arguments:
                  <name> <payload> <name> <payload> ... [max %u payloads]
    acme-dns-01-flush - Flush (remove) all ACME DNS-01 payloads added above

=head1 DESCRIPTION

B<gdnsdctl> is the canonical control socket client for B<gdnsd>.  All
operations described above are synchronous and report success by exiting with
exit status zero, or failure by non-zero.

=head1 COMMANDLINE OPTION FLAGS

=over 4

=item B<-c>

Set the configuration directory, defaults to F<@GDNSD_DEFPATH_CONFIG@>.

=item B<-D>

Enables additional debug-level log output as appropriate.

=item B<-l>

Sends log output to syslog rather than the default stderr.

=item B<-t>

Sets the timeout in seconds (default 47) for various io and waiting operations.

=back

=head1 Actions

=over 4

=item B<stop>

Synchronously stops the running daemon.  Exit status zero means the daemon was
observed to stop as commanded.

=item B<reload-zones>

Synchronously reloads the daemon's zonefiles.  Exit status zero indicates the
operation completed successfully and the new data is visible to clients.

=item B<replace>

Ask the running daemon to spawn a replacement instance of itself.  This can be
used for code upgrades and/or configuration changes.  The replacement daemon is
initially executed as a child of the running daemon and thus inherits many
attributes of its execution environment.  The old and new daemons coordinate a
handoff process over an inter-daemon control socket connection.  The handoff
process does its best to ensure that if the new daemon fails at any stage of
startup, the old daemon can continue operations as it was before.

DNS listening sockets are handed off in an overlapped fashion: there will be a
brief window of time where client requests can be routed to either daemon
randomly, but there should never be a window where service is unavailable.  The
control socket itself is handed off synchronously: the old daemon stops
listening for new connections before the new daemon begins listening, and the
old daemon re-starts listening if the new daemon fails to succeed completely.
During the entire replacement process, the old daemon will deny control socket
requests clients for any stateful operations (e.g. other C<replace> requests,
C<reload-zones>, C<acme-dns-01>).  The takeover process ensures that any
successful stateful operations which happened (even just barely) before the
replacement remain valid.  The challenge data carries over, and the new daemon
will have loaded the zone data at or after the point the last reload-zones
operation did so.

Once the old daemon claims the replacement process was successful, gdnsdctl
will monitor the old daemon's exit and then make a fresh connection to the
control socket of the new daemon and check its status.  If all of this is
successful, the replace command will finally exit with status zero.  It will
exit with a non-zero status if any part of this operation fails for any reason,
which should in most conceivable cases leave the existing daemon fully
functional (if there was one!).

=item B<status>

Checks the running daemon's status, reporting its PID and version to stderr.

=item B<stats>

Dumps JSON statistics from the running daemon to stdout.

=item B<states>

Dumps JSON monitored states from any configured service health monitors.

=item B<acme-dns-01>

Injects temporary ACME DNS-01 challenge response payloads as defined by
L<https://tools.ietf.org/html/draft-ietf-acme-acme-14> into the running daemon.
This is intended for integration with scripts or services which generate signed
certificates from an ACME-capable certificate authority.

Two or more additional commandline arguments are required, in pairs of C<name>
and C<payload>, where C<name> is a valid domainname and C<payload> is the
challenge response payload (which, as a SHA-256 output encoded in base64url
encoding, should be 43 bytes long and consist of only alphanumeric characters
plus C<-> and C<_>).  A maximum of 100 separate payloads can be specified in a
single gdnsdctl invocation.

This example...

    gdnsdctl acme-dns-01 example.org 0123456789012345678901234567890123456789012 www.example.org ABCDEFGHIJKLMNOPQRSTUVWXYZ-abcdefghijklmnop

... causes the daemon to temporarily respond to C<TXT> requests for the name
C<_acme-challenge.example.org.> with the first payload above, and similarly
with the second payload for C<_acme-challenge.www.example.org.>.

Challenge payload responses injected by this command automatically expire after
a short time.  The default is 10 minutes, and is configurable via the config
option C<acme_challenge_ttl>.  This is also emitted as the TTL of the TXT
records themselves.

Injecting responses for domainnames that are not within the scope of one of the
statically-configured zones will succeed, but the response to such queries will
still be C<REFUSED>.

If more than one payload is configured for a given name (in the same command,
or in separate commands less than the TTL window apart), multiple TXT records
will be emitted.  If there is any statically-configured TXT data from zonefiles
at a conflicting C<_acme-challenge> name, the static TXT RRs will also be
served alongside any data from this mechanism.

As an implementail detail (quirk?) of this mechanism, any static zonefile RRs
which have a first label of C<_acme-challenge> will automatically have their
TTLs forced to the C<acme_challenge_ttl> regardless of the TTL specified in the
zonefile.  This was the easiest way to ensure that we never serve mixed TTL
values in a single RR-set of TXT records, which is forbidden by RFC 2181.

The data injected by this mechanism persists through daemon C<replace>
operations, but not through a full C<stop> of the daemon.  It also persists
through zone data reloads, and in the case that data is injected for a
non-existent zone which then comes into existence through a reload, the
challenge will begin working after the reload.

=item B<acme-dns-01-flush>

Immediately flushes all injected payload data from above ahead of its natural
expiry.  Mostly useful for testing or for clearing up mistakes, but some
integrations with spiky large volumes of challenges may wish to flush data
explicitly at points in time when there are no outstanding DNS-01 challenges.

=back

=head1 EXIT STATUS

In general, all operations exit with status zero if and only if the operation
is successful.  Errors and most other output go to stderr, except in the case
of JSON data dumps, which go to stdout.

=head1 SEE ALSO

L<gdnsd(8)>, L<gdnsd.config(5)>, L<gdnsd.zonefile(5)>, L<gdnsd.djbdns(5)>

The gdnsd manual.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2012 Brandon L Black <blblack@gmail.com>

This file is part of gdnsd.

gdnsd is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

gdnsd is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with gdnsd.  If not, see <http://www.gnu.org/licenses/>.

=cut
